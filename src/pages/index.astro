---
import Layout from '../layouts/Layout.astro';
import "../styles/global.css";
import assetsData from '../assets/assets.json'; // Import the assets JSON

const assets = assetsData.map(asset => asset.assetCode); // Extract asset codes



---

<Layout>
  <head>
    <!-- Other head elements -->
  </head>
  <main class="container mx-auto px-4 pt-6 max-w-7xl">
    <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
      <!-- Left side - Form -->
      <div class="md:col-span-1">
        <div class="bg-gray-50 rounded-lg shadow-lg p-4">
          <h2 class="text-2xl font-bold mb-6 text-gray-800">Swap Routes</h2>
          
          <form id="swapForm" class="space-y-4 max-w-md">
            <!-- Source Asset -->
            <div>
              <label for="sourceAsset" class="block text-sm font-medium text-gray-700">
                Source Asset
              </label>
              <select
                id="sourceAsset"
                name="sourceAsset"
                class="mt-1 block w-full rounded-md border border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2"
                required
              >
                <option value="">Select source asset</option>
                {assets.map((asset) => (
                  <option value={asset}>{asset}</option>
                ))}
              </select>
            </div>

            <!-- Slippage Tolerance -->
            <div>
              <label for="slippageTolerance" class="block text-sm font-medium text-gray-700">
                Slippage Tolerance (%)
              </label>
              <input
                type="number"
                id="slippageTolerance"
                name="slippageTolerance"
                min="0"
                step="0.01"
                class="mt-1 block w-full rounded-md border border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2"
                placeholder="Enter slippage tolerance"
                value="2"
              />
            </div>

            <!-- Source Amount -->
            <div>
              <label for="sourceAmount" class="block text-sm font-medium text-gray-700">
                Amount
              </label>
              <input
                type="number"
                id="sourceAmount"
                name="sourceAmount"
                min="0"
                step="any"
                class="mt-1 block w-full rounded-md border border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2"
                placeholder="Enter amount"
              />
            </div>

            <!-- Destination Asset -->
            <div>
              <label for="destinationAsset" class="block text-sm font-medium text-gray-700">
                Destination Asset
              </label>
              <select
                id="destinationAsset"
                name="destinationAsset"
                class="mt-1 block w-full rounded-md border border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2"
                required
              >
                <option value="">Select destination asset</option>
                {assets.map((asset) => (
                  <option value={asset}>{asset}</option>
                ))}
              </select>
            </div>

            <!-- Destination Amount -->
            <div>
              <label for="destinationAmount" class="block text-sm font-medium text-gray-700">
                Amount
              </label>
              <input
                type="number"
                id="destinationAmount"
                name="destinationAmount"
                min="0"
                step="any"
                class="mt-1 block w-full rounded-md border border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2"
                placeholder="Enter amount"
              />
            </div>

            <button
              type="submit"
              class="w-full bg-indigo-600 text-white py-2 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
            >
              Find Path
            </button>
          </form>
        </div>
      </div>

      <!-- Right side - Results container -->
      <div class="md:col-span-2">
        <div class="bg-white rounded-lg p-0 min-h-[500px]">
          <div id="pathResult" class="space-y-4">
            <!-- Results will be displayed here -->
          </div>
        </div>
      </div>
    </div>
  </main>
</Layout>

<!-- New section for displaying responses -->
<div class="response-section mt-6">
	<div class="bg-white p-4">
	<h3 class="text-xl font-semibold mb-2">Responses</h3>
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
      <div id="stellarResponse" class="bg-gray-100 p-4 rounded-lg overflow-auto">
        <h4 class="font-semibold">Path Payment</h4>
        <pre><code class="json small-code"></code></pre>
      </div>
      <div id="soroswapResponse" class="bg-gray-100 p-4 rounded-lg overflow-auto">
        <h4 class="font-semibold">Soroswap</h4>
        <pre><code class="json small-code"></code></pre>
      </div>
      <div id="stellarBrokerResponse" class="bg-gray-100 p-4 rounded-lg overflow-auto">
        <h4 class="font-semibold">Stellar Broker</h4>
        <pre><code class="json small-code"></code></pre>
      </div>
    </div>
  </div>
</div>

<script>
	import assetsData from '../assets/assets.json'; // Import the assets JSON
  // Add proper types for Soroswap imports
//   let Router: any, Token: any, CurrencyAmount: any, TradeType: any, Networks: any, Protocol: any;
  let server: any;
  let StellarSdk: any;

  const tokenAddresses: Record<string, string> = assetsData.reduce((acc, asset) => {
  acc[asset.assetCode] = asset.homeDomain; // Use homeDomain for each asset code
  return acc;
}, {
  'XLM': 'CAS3J7GYLGXMF6TDJBBYYSE3HQ6BBSMLNUQ34T6TZMYMW2EVH34XOWMA', // Add XLM address
});

  // Initialize both SDKs
  async function initSDKs() {
    if (!StellarSdk) {
      StellarSdk = await import('@stellar/stellar-sdk');
      server = new StellarSdk.Horizon.Server('https://horizon.stellar.org');
    }
  }
  import {
  Router,
  Token,
  CurrencyAmount,
  TradeType,
  Networks,
  Protocol
} from "soroswap-router-sdk";

  const form = document.getElementById('swapForm') as HTMLFormElement;
  const sourceAmount = document.getElementById('sourceAmount') as HTMLInputElement;
  const destinationAmount = document.getElementById('destinationAmount') as HTMLInputElement;
  const pathResult = document.getElementById('pathResult');

  // Set default values
  if (form) {
    const sourceAssetSelect = form.querySelector('#sourceAsset') as HTMLSelectElement;
    const destAssetSelect = form.querySelector('#destinationAsset') as HTMLSelectElement;
    
    sourceAssetSelect.value = 'XLM';
    destAssetSelect.value = 'USDC';
    sourceAmount.value = '100';
  }

  // Handle amount input focus
  sourceAmount?.addEventListener('focus', () => {
    if (destinationAmount) destinationAmount.value = '';
  });

  destinationAmount?.addEventListener('focus', () => {
    if (sourceAmount) sourceAmount.value = '';
  });

  const DEBUG = true;  // Toggle debugging

  // Helper function to create a token
  function createToken(asset: string, tokenAddresses: Record<string, string>, assetNames: Record<string, string>) {
    return new Token(
      Networks.PUBLIC,
      tokenAddresses[asset],
      7,
      asset,
      assetNames[asset]
    );
  }

  // Function to create router with debug logging
  function createRouter() {
    return new Router({
      pairsCacheInSeconds: 20,
      protocols: [Protocol.SOROSWAP],
      network: Networks.PUBLIC,
      onBeforeRequest: DEBUG ? (url: string, init: RouterConfig) => {
        console.log('Making API request:', { 
          url,
          method: init?.init?.method,
          headers: init?.init?.headers
        });
      } : undefined,
      onAfterResponse: DEBUG ? (url: string, response: RouterResponse) => {
        console.log('API response:', { 
          url, 
          status: response.status,
          ok: response.status >= 200 && response.status < 300
        });
      } : undefined
    });
  }

  // Update the findSoroswapPath function
  async function findSoroswapPath(sourceAsset: string, destAsset: string, amount: string) {
    console.log('Starting findSoroswapPath with:', { sourceAsset, destAsset, amount });

    const assetNames: Record<string, string> = {
      'XLM': 'Stellar Lumens',
      'USDC': 'USD Coin',
      'ETH': 'Ethereum',
      'BTC': 'Bitcoin',
      // Add more asset names as needed
    };

    // Check if we have addresses for both assets
    if (!tokenAddresses[sourceAsset] || !tokenAddresses[destAsset]) {
      console.error('Token address not found:', {
        sourceAsset,
        sourceAddress: tokenAddresses[sourceAsset],
        destAsset,
        destAddress: tokenAddresses[destAsset]
      });
      return null;
    }

    try {
      const sourceToken = createToken(sourceAsset, tokenAddresses, assetNames);
      const destToken = createToken(destAsset, tokenAddresses, assetNames);

      const router = createRouter();

      // Convert amount to the smallest unit (7 decimals)
      const rawAmount = Math.floor(parseFloat(amount) * 10000000).toString();
      const currencyAmount = CurrencyAmount.fromRawAmount(sourceToken, rawAmount);

      const route = await router.route(currencyAmount, destToken, TradeType.EXACT_INPUT);

      // Check if route exists and has trade property
      if (!route || !route.trade) {
        console.error('Route is null or trade is null:', route);
        return null;
      }

      const result = {
        path: route.trade.path || [],
        inputAmount: route.trade.inputAmount.toSignificant(6),
        outputAmount: route.trade.outputAmount.toSignificant(6)
      };

      console.log('Successfully found route:', result);
      return result;

    } catch (error: unknown) {
      console.error('Soroswap path error:', error);
      if (error instanceof Error) {
        console.error('Error details:', {
          message: error.message,
          stack: error.stack
        });
      }
      return null;
    }
  }


import {estimateSwap} from '@stellar-broker/client'

async function estimateSwapForAssets(sourceAsset: string, destAsset: string, amount: string, slippageTolerance: number) {
    const issuers: Record<string, string> = Object.keys(tokenAddresses).reduce((acc, asset) => {
      acc[asset] = tokenAddresses[asset]; // Automatically list all assets and their issuers
      return acc;
    }, {} as Record<string, string>);

    const formattedSourceAsset = sourceAsset === 'XLM' ? 'xlm' : `${sourceAsset}-${issuers[sourceAsset]}`;
    const formattedDestAsset = destAsset === 'XLM' ? 'xlm' : `${destAsset}-${issuers[destAsset]}`;

    const result = await estimateSwap({
        sellingAsset: formattedSourceAsset,
        buyingAsset: formattedDestAsset,
        sellingAmount: amount, 
        slippageTolerance: slippageTolerance
    });
	
    console.log('Estimate swap result:', result);
	return result;
}


  // Function to update the response output section
  function updateResponseOutput(responses) {
    const stellarResponse = document.getElementById('stellarResponse').querySelector('code');
    const soroswapResponse = document.getElementById('soroswapResponse').querySelector('code');
    const stellarBrokerResponse = document.getElementById('stellarBrokerResponse').querySelector('code');

    stellarResponse.textContent = JSON.stringify(responses.stellarResult, null, 2);
    soroswapResponse.textContent = JSON.stringify(responses.soroswapResult, null, 2);
    stellarBrokerResponse.textContent = JSON.stringify(responses.stellarBrokerResult, null, 2);
  }

  // Function to handle Stellar swap
  async function handleStellarSwap(sourceAsset: string, destAsset: string, amount: string, isStrictSend: boolean) {
    return await findPathPayment(sourceAsset, destAsset, amount, isStrictSend);
  }

  // Function to handle Soroswap
  async function handleSoroswap(sourceAsset: string, destAsset: string, amount: string) {
    return await findSoroswapPath(sourceAsset, destAsset, amount);
  }

  // Function to handle Stellar Broker
  async function handleStellarBroker(sourceAsset: string, destAsset: string, amount: string, slippageTolerance: number) {
    return await estimateSwapForAssets(sourceAsset, destAsset, amount, slippageTolerance);
  }

  // Update the form submission handler to use the new functions
  form?.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    await initSDKs();

    const formData = new FormData(form);
    const sourceAsset = formData.get('sourceAsset')?.toString() || '';
    const destAsset = formData.get('destinationAsset')?.toString() || '';
    const srcAmount = formData.get('sourceAmount')?.toString() || '0';
    const destAmount = formData.get('destinationAmount')?.toString() || '0';
    const slippageTolerance = parseFloat(formData.get('slippageTolerance')?.toString() || '0') / 100; // Capture slippage tolerance as a decimal

    if (!sourceAsset || !destAsset) {
      alert('Please select both assets');
      return;
    }

    if (!srcAmount && !destAmount) {
      alert('Please enter either source or destination amount');
      return;
    }

    if (!pathResult) return;

    try {
      pathResult.innerHTML = '<p class="text-gray-600">Searching for paths...</p>';

      const isStrictSend = Boolean(srcAmount);
      
      // Get both Stellar and Soroswap paths, and add Stellar Broker path
      const [stellarResult, soroswapResult, stellarBrokerResult] = await Promise.all([
        handleStellarSwap(sourceAsset || '', destAsset || '', isStrictSend ? srcAmount : destAmount, isStrictSend),
        handleSoroswap(sourceAsset || '', destAsset || '', (srcAmount || destAmount)),
        handleStellarBroker(sourceAsset, destAsset, srcAmount || destAmount, slippageTolerance) // Pass slippage tolerance
      ]);

      console.log('Stellar Broker Result:', stellarBrokerResult);

      // Update the response output section
      updateResponseOutput({ stellarResult, soroswapResult, stellarBrokerResult });

      // Handle Soroswap result
      if (!soroswapResult) {
        console.warn('No Soroswap path found.');
      }

      // Update the display to show all results
      pathResult.innerHTML = `
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 response-section">
          <div>
            <h3 class="text-xl font-semibold mb-2">Path Payment</h3>
            <div class="bg-white p-3 rounded-lg shadow-lg border border-gray-200">
              <p class="mb-1">
                <span class="font-medium">Source:</span> 
                ${stellarResult.source.amount} ${stellarResult.source.asset}
              </p>
              <p class="mb-1">
                <span class="font-medium">Destination:</span> 
                ${stellarResult.destination.amount} ${stellarResult.destination.asset}
              </p>
              <p class="text-sm text-gray-600 mt-2">
                Exchange rate: 1 ${sourceAsset} = ${(
                  Number(stellarResult.destination.amount) / Number(stellarResult.source.amount)
                ).toFixed(7)} ${destAsset}
              </p>
              <p class="text-sm text-gray-600 mt-2">
                Direction: ${isStrictSend ? 'Strict Send' : 'Strict Receive'}
              </p>
              ${stellarResult.path.length > 0 ? `
                <div class="mt-2">
                  <p class="font-medium">Path:</p>
                  <p class="text-sm text-gray-600">${stellarResult.path.join(' → ')}</p>
                </div>
              ` : ''}
              <div class="mt-2 p-2 bg-gray-100 rounded">
                <p class="font-medium mb-1">Estimated Transaction Fees (XLM):</p>
                <p class="text-sm">Minimum: ${stellarResult.fees.min}</p>
                <p class="text-sm">Maximum: ${stellarResult.fees.max}</p>
                <p class="text-sm">Median: ${stellarResult.fees.median}</p>
              </div>
            </div>
          </div>
          
          <div>
            <h3 class="text-xl font-semibold mb-2">Soroswap Aggregator</h3>
            <div class="bg-white p-3 rounded-lg shadow-lg border border-gray-200">
              ${soroswapResult ? `
                <p class="mb-1">
                  <span class="font-medium">Input:</span> 
                  ${soroswapResult.inputAmount} ${sourceAsset}
                </p>
                <p class="mb-1">
                  <span class="font-medium">Output:</span> 
                  ${soroswapResult.outputAmount} ${destAsset}
                </p>
                <p class="text-sm text-gray-600 mt-2">
                  Exchange rate: 1 ${sourceAsset} = ${(
                    Number(soroswapResult.outputAmount) / Number(soroswapResult.inputAmount)
                  ).toFixed(7)} ${destAsset}
                </p>
                ${soroswapResult.path.length > 0 ? `
                  <div class="mt-2">
                    <p class="font-medium">Path:</p>
                    <p class="text-sm text-gray-600">${soroswapResult.path.join(' → ')}</p>
                  </div>
                ` : ''}
              ` : `
                <p class="text-red-600">No Soroswap path found.</p>
              `}
            </div>
          </div>

          <div>
            <h3 class="text-xl font-semibold mb-2">Stellar Broker</h3>
            <div class="bg-white p-3 rounded-lg shadow-lg border border-gray-200">
              ${stellarBrokerResult ? `
                <p class="mb-1">
                  <span class="font-medium">Source:</span> 
                  ${stellarBrokerResult.sellingAmount} ${sourceAsset}
                </p>
                <p class="mb-1">
                  <span class="font-medium">Destination:</span> 
                  ${stellarBrokerResult.estimatedBuyingAmount} ${destAsset}
                </p>
                <p class="text-sm text-gray-600 mt-2">
                  Exchange rate: 1 ${sourceAsset} = ${(
                    Number(stellarBrokerResult.estimatedBuyingAmount) / Number(stellarBrokerResult.sellingAmount)
                  ).toFixed(7)} ${destAsset}
                </p>
                <p class="text-sm text-gray-600 mt-2">
                  Direction: ${stellarBrokerResult.direction}
                </p>
                <p class="text-sm text-gray-600 mt-2">
                  Slippage Tolerance: ${stellarBrokerResult.slippageTolerance*100}%
                </p>
                <p class="text-sm text-gray-600 mt-2">
                  Profit: ${stellarBrokerResult.profit} ${destAsset}
                </p>
                ${stellarBrokerResult.directTrade.path.length > 0 ? `
                  <p class="font-medium">Path:</p>
                  <p class="text-sm text-gray-600">${stellarBrokerResult.directTrade.path.join(' → ')}</p>
                ` : `
                  <p class="text-yellow-600 text-sm mt-2">Direct trade available: You can sell ${stellarBrokerResult.sellingAmount} ${sourceAsset} for ${stellarBrokerResult.estimatedBuyingAmount} ${destAsset} without a defined path.</p>
                `}
              ` : `
                <p class="text-red-600">No Stellar Broker path found.</p>
              `}
            </div>
          </div>
        </div>
      `;
    } catch (error: unknown) {
      pathResult.innerHTML = `
        <div class="text-red-600">
          Error finding paths: ${error instanceof Error ? error.message : 'Unknown error occurred'}
        </div>
      `;
    }
  });

  async function findPathPayment(sourceAsset: string, destAsset: string, amount: string | null, isStrictSend: boolean) {
    if (!amount) throw new Error('Amount is required');
    
    // Convert asset codes to Stellar Asset objects
    const getAsset = (code: string) => {
      if (code === 'XLM') {
        return new StellarSdk.Asset.native();
      }
      // For non-native assets, you'll need to specify the issuer
      const issuers: Record<string, string> = Object.keys(tokenAddresses).reduce((acc, asset) => {
  acc[asset] = tokenAddresses[asset]; // Automatically list all assets and their issuers
  return acc;
}, {} as Record<string, string>);
      
      if (!issuers[code]) {
        throw new Error(`Issuer not found for asset ${code}`);
      }
      
      return new StellarSdk.Asset(code, issuers[code]);
    };

    const stellarSourceAsset = getAsset(sourceAsset);
    const stellarDestAsset = getAsset(destAsset);

    try {
      // Get fee stats from Horizon
      const feeStats = await server.feeStats()
        .then(function(resp: any) {
          return resp;
        })
        .catch(function(err: Error) {
          console.error('Fee stats error:', err);
          // Return default values if fee stats fails
          return {
            last_ledger: '',
            last_ledger_base_fee: '100',
            ledger_capacity_usage: '',
            fee_charged: {
              min: '100',
              max: '1000',
              mode: '100'
            }
          };
        });

      const feesInStroops = {
        min: feeStats.fee_charged.min,
        max: feeStats.fee_charged.max,
        median: feeStats.fee_charged.mode  // Using mode as median
      };
      
      // Convert stroops to XLM (1 XLM = 10000000 stroops)
      const feesInXLM = {
        min: (parseInt(feesInStroops.min) / 10000000).toFixed(7),
        max: (parseInt(feesInStroops.max) / 10000000).toFixed(7),
        median: (parseInt(feesInStroops.median) / 10000000).toFixed(7)
      };

      let pathData;
      
      if (isStrictSend) {
        pathData = await server
          .strictSendPaths(
            stellarSourceAsset,
            amount,
            [stellarDestAsset]
          )
          .call();
      } else {
        pathData = await server
          .strictReceivePaths(
            [stellarSourceAsset],
            stellarDestAsset,
            amount
          )
          .call();
      }

      if (!pathData.records || pathData.records.length === 0) {
        throw new Error('No path found between these assets');
      }

      const bestPath = pathData.records[0];
      
      return {
        source: {
          asset: sourceAsset,
          amount: bestPath.source_amount
        },
        destination: {
          asset: destAsset,
          amount: bestPath.destination_amount
        },
        path: bestPath.path.map((asset: any) => 
          asset.asset_type === 'native' ? 'XLM' : asset.asset_code
        ),
        fees: feesInXLM
      };
    } catch (error: unknown) {
      if (error instanceof Error) {
        throw new Error(error.message);
      }
      throw error;
    }
  }
  
</script>
